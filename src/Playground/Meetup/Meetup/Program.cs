using System.Reactive;
using EventSourcing;
using EventSourcing.Commands;
using EventSourcing.Infrastructure;
using Meetup.SerializedPayloads;

namespace Meetup;

//Add a static partial class attributed with the CommandExtensions<TResult, TError> attribute and EventSourcing commands package will add some
//useful extensions and command processor base classes for your result and error type.
//TResult has to implement EventSourcing.Commands.IResult (which is automatically working with result types generated by FunicularSwitch.Generators package)
//TError has to implement EventSourcing.Commands.IError
[CommandExtensions<Result<Unit>, Error>]
public static partial class CommandExtensions
{
}

public static class Program
{
	public static async Task Main(string[] args)
	{
		var builder = WebApplication.CreateBuilder(args);
		var services = builder.Services;
		
		services.AddEventSourcing(es => es
            //.UseSqlServerEventStore(@"Data Source=.\SQLSERVEREXPRESS;Initial Catalog=Meetup;Integrated Security=True;TrustServerCertificate=True")
            .UseSqliteEventStore(@"Data Source=.\EventStore.db")
            //.UseInMemoryEventStore()
            .UseFunicularCommands<Error, ErrorPayload>());

		services
            .AddInitializer<TalksProjection>(serviceLifetime: ServiceLifetime.Singleton, asSelf: true);

        services.AddGraphQLApi();

		var app = builder.Build();

		app
			.UseRouting()
			.UseWebSockets()
			.UseEndpoints(endpoints => endpoints.MapGraphQL());

		await app.Services.StartEventSourcing();

		await app.RunAsync();
	}

    static IServiceCollection AddGraphQLApi(this IServiceCollection services)
    {
        services.AddGraphQLServer()
            .AddQueryType<Query>()
            .AddMutationType<Mutation>()
            .AddSubscriptionType<Subscription>();

        return services;
    }
}