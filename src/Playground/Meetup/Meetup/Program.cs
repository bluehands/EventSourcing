using EventSourcing;
using EventSourcing.Commands;
using EventSourcing.Infrastructure;
using Meetup.SerializedPayloads;

namespace Meetup;

//Add a partial class attributed with the CommandExtensions<TResult, TFailure> attribute and EventSourcing commands package will add some
//useful extensions and command processor base classes for your result and failure type.
//TResult has to implement EventSourcing.Commands.IResult (which is automatically working with result types generated by FunicularSwitch.Generators package)
//TFailure has to implement EventSourcing.Commands.IFailure
[CommandExtensions<Result, Failure>]
public static partial class CommandExtensions
{
}

public static class Program
{
	public static async Task Main(string[] args)
	{
		var builder = WebApplication.CreateBuilder(args);
		var services = builder.Services;
		
		services.AddEventSourcing(es => es
            //.UseSqlServerEventStore(@"Data Source=.\SQLSERVEREXPRESS;Initial Catalog=Meetup;Integrated Security=True;TrustServerCertificate=True")
            .UseSqliteEventStore(@"Data Source=.\EventStore.db")
            //.UseInMemoryEventStore()
            .UseFunicularCommands<Failure, FailurePayload>());

		services
            .AddInitializer<TalksProjection>(serviceLifetime: ServiceLifetime.Singleton, asSelf: true);

        services.AddGraphQLApi();

		var app = builder.Build();

		app
			.UseRouting()
			.UseWebSockets()
			.UseEndpoints(endpoints => endpoints.MapGraphQL());

		await app.Services.StartEventSourcing();

		await app.RunAsync();
	}

    static IServiceCollection AddGraphQLApi(this IServiceCollection services)
    {
        services.AddGraphQLServer()
            .AddQueryType<Query>()
            .AddMutationType<Mutation>()
            .AddSubscriptionType<Subscription>();

        return services;
    }
}